<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Тип данных Symbol</title>
</head>

<body>
  <h3>Тип данных Symbol</h3>
  <p>
    По спецификации, в качестве ключей для свойств объекта могут использоваться только строки или символы. Ни числа, ни
    логические значения не подходят, разрешены только эти два типа данных.
    До сих пор мы видели только строки. Теперь давайте разберём символы, увидим, что хорошего они нам дают.
    Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно
    будут разные символы. Описание – это просто метка, которая ни на что не влияет.

    let id1 = Symbol("id");
    let id2 = Symbol("id");
    alert(id1 == id2); // false
  </p>

  <h3>«Скрытые» свойства</h3>
  <p>
    Символы позволяют создавать «скрытые» свойства объектов, к которым нельзя нечаянно обратиться и перезаписать их из
    других частей программы.
    Например, мы работаем с объектами user, которые принадлежат стороннему коду. Мы хотим добавить к ним идентификаторы.
    Используем для этого символьный ключ:

    let user = {
    name: "Вася"
    };

    let id = Symbol("id");

    user[id] = 1;

    alert( user[id] ); // мы можем получить доступ к данным по ключу-символу

    Так как объект user принадлежит стороннему коду, и этот код также работает с ним, то нам не следует добавлять к нему
    какие-либо поля. Это небезопасно. Но к символу сложно нечаянно обратиться, сторонний код вряд ли его вообще увидит,
    и, скорее всего, добавление поля к объекту не вызовет никаких проблем.

    Кроме того, предположим, что другой скрипт для каких-то своих целей хочет записать собственный идентификатор в
    объект user. Этот скрипт может быть какой-то JavaScript-библиотекой, абсолютно не связанной с нашим скриптом.
  </p>
  <h3>Символы игнорируются циклом for…in</h3>
  <p>
    Свойства, чьи ключи – символы, не перебираются циклом for..in.

    let id = Symbol("id");
    let user = {
    name: "Вася",
    age: 30,
    [id]: 123
    };

    for (let key in user) alert(key); // name, age (свойства с ключом-символом нет среди перечисленных)
    // хотя прямой доступ по символу работает
    alert( "Напрямую: " + user[id] );

    Это – часть общего принципа «сокрытия символьных свойств». Если другая библиотека или скрипт будут работать с нашим
    объектом, то при переборе они не получат ненароком наше символьное свойство. Object.keys(user) также игнорирует
    символы.
    А вот Object.assign, в отличие от цикла for..in, копирует и строковые, и символьные свойства.
    Здесь нет никакого парадокса или противоречия. Так и задумано. Идея заключается в том, что, когда мы клонируем или
    объединяем объекты, мы обычно хотим скопировать все свойства (включая такие свойства с ключами-символами, как,
    например, id в примере выше).
  </p>

  <h3>Symbol.keyFor</h3>
  <p>
    Для глобальных символов, кроме Symbol.for(key), который ищет символ по имени, существует обратный метод:
    Symbol.keyFor(sym), который, наоборот, принимает глобальный символ и возвращает его имя.

    // получаем символ по имени
    let sym = Symbol.for("name");
    let sym2 = Symbol.for("id");

    // получаем имя по символу
    alert( Symbol.keyFor(sym) ); // name
    alert( Symbol.keyFor(sym2) ); // id

    Внутри метода Symbol.keyFor используется глобальный реестр символов для нахождения имени символа. Так что этот метод
    не будет работать для неглобальных символов. Если символ неглобальный, метод не сможет его найти и вернёт undefined.
    Впрочем, для любых символов доступно свойство description.
  </p>

  <h3>Итого</h3>

  <p>
    Символ (symbol) – примитивный тип данных, использующийся для создания уникальных идентификаторов.
    Символы создаются вызовом функции Symbol(), в которую можно передать описание (имя) символа.
    Даже если символы имеют одно и то же имя, это – разные символы. Если мы хотим, чтобы одноимённые символы были равны,
    то следует использовать глобальный реестр: вызов Symbol.for(key) возвращает (или создаёт) глобальный символ с key в
    качестве имени. Многократные вызовы команды Symbol.for с одним и тем же аргументом возвращают один и тот же символ.
    Символы имеют два основных варианта использования:

    «Скрытые» свойства объектов.

    Если мы хотим добавить свойство в объект, который «принадлежит» другому скрипту или библиотеке, мы можем создать
    символ и использовать его в качестве ключа. Символьное свойство не появится в for..in, так что оно не будет нечаянно
    обработано вместе с другими. Также оно не будет модифицировано прямым обращением, так как другой скрипт не знает о
    нашем символе. Таким образом, свойство будет защищено от случайной перезаписи или использования.

    Так что, используя символьные свойства, мы можем спрятать что-то нужное нам, но что другие видеть не должны.

    Существует множество системных символов, используемых внутри JavaScript, доступных как Symbol.*. Мы можем
    использовать их, чтобы изменять встроенное поведение ряда объектов. Например, в дальнейших главах мы будем
    использовать Symbol.iterator для итераторов, Symbol.toPrimitive для настройки преобразования объектов в примитивы и
    так далее.

    Технически символы скрыты не на 100%. Существует встроенный метод Object.getOwnPropertySymbols(obj) – с его помощью
    можно получить все свойства объекта с ключами-символами. Также существует метод Reflect.ownKeys(obj), который
    возвращает все ключи объекта, включая символьные. Так что они не совсем спрятаны. Но большинство библиотек,
    встроенных методов и синтаксических конструкций не используют эти методы.
  </p>
</body>

</html>