<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>This and methods</title>
</head>

<body>
  <h2>Запись методов</h2>
  <p>
    let user = {
    name: "John",
    age: 30
    };

    user.sayHi = function() {
    alert("Привет!");
    };

    user.sayHi(); // Привет!
  </p>
  <p>
    Здесь мы просто использовали Function Expression (функциональное выражение), чтобы создать функцию приветствия, и
    присвоили её свойству user.sayHi нашего объекта.
    Функцию, которая является свойством объекта, называют методом этого объекта.
  </p>

  <p>
    let user = {
    // ...
    };

    // сначала, объявляем
    function sayHi() {
    alert("Привет!");
    }

    // затем добавляем в качестве метода
    user.sayHi = sayHi;

    user.sayHi(); // Привет!
  </p>
  <p>
    мы использовали заранее объявленную функцию в качестве метода
  </p>

  <p>Два варианта короткой записи</p>
  <p>
    // эти объекты делают одно и то же

    user = {
    sayHi: function() {
    alert("Привет");
    }
    };

    // сокращённая запись выглядит лучше, не так ли?
    user = {
    sayHi() { // то же самое, что и "sayHi: function(){...}"
    alert("Привет");
    }
    };
  </p>

  <h2>
    Ключевое слово «this» в методах
  </h2>

  <p>
    Как правило, методу объекта обычно требуется доступ к информации, хранящейся в объекте, для выполнения своей работы.

    Например, коду внутри user.sayHi() может потребоваться имя пользователя, которое хранится в объекте user.

    Для доступа к информации внутри объекта метод может использовать ключевое слово this.

    Значение this – это объект «перед точкой», который используется для вызова метода.
  </p>
  <p>
    let user = {
    name: "John",
    age: 30,

    sayHi() {
    // "this" - это "текущий объект".
    alert(this.name);
    }

    };

    user.sayHi(); // John
  </p>
  <p>
    Здесь во время выполнения кода user.sayHi() значением this будет являться user (ссылка на объект user).
    Технически также возможно получить доступ к объекту без ключевого слова this, обратившись к нему через внешнюю
    переменную (в которой хранится ссылка на этот объект):
  </p>
  <p>
    let user = {
    name: "John",
    age: 30,

    sayHi() {
    alert(user.name); // "user" вместо "this"
    }

    };
  </p>

  <h2>«this» не является фиксированным</h2>
  <p>
    В JavaScript ключевое слово «this» ведёт себя иначе, чем в большинстве других языков программирования. Его можно
    использовать в любой функции, даже если это не метод объекта.
  </p>
  <p>
    let user = { name: "John" };
    let admin = { name: "Admin" };

    function sayHi() {
    alert( this.name );
    }

    // используем одну и ту же функцию в двух объектах
    user.f = sayHi;
    admin.f = sayHi;

    // эти вызовы имеют разное значение this
    // "this" внутри функции - это объект "перед точкой"
    user.f(); // John (this == user)
    admin.f(); // Admin (this == admin)

    admin['f'](); // Admin (нет разницы между использованием точки или квадратных скобок для доступа к объекту)
  </p>
  <p>
    Правило простое: если вызывается obj.f(), то во время вызова f, this – это obj. Так что, в приведённом выше примере
    это либо user, либо admin.
  </p>

  <h2>
    Итого
  </h2>
  <p>
    Функции, которые находятся в свойствах объекта, называются «методами».
    Методы позволяют объектам «действовать»: object.doSomething().
    Методы могут ссылаться на объект через this.

    Значение this определяется во время исполнения кода.

    При объявлении любой функции в ней можно использовать this, но этот this не имеет значения до тех пор, пока функция
    не будет вызвана.
    Функция может быть скопирована между объектами (из одного объекта в другой).
    Когда функция вызывается синтаксисом «метода» – object.method(), значением this во время вызова является object.

    Также ещё раз заметим, что стрелочные функции являются особенными – у них нет this. Когда внутри стрелочной функции
    обращаются к this, то его значение берётся извне.
  </p>
</body>

</html>